*** Begin Patch
*** Update File: src/routes/auth.ts
@@
-import { Elysia } from "elysia";
-import { z } from "zod";
+import { Elysia } from "elysia";
+import { z } from "zod";
+import bcrypt from "bcryptjs";
+import jwt from "jsonwebtoken";
+import { pool } from "../config/database";
+import { nanoid } from "nanoid";
+import { ratelimitByIp } from "../utils/ratelimit";
+
+const PASSWORD_RULES =
+  /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[!@#$%^&*()_+\-={}\[\]:;"'`<>,.?\/]).{8,}$/;
@@
-const signupSchema = z.object({
-  email: z.string().email(),
-  password: z.string().min(6),
-  firstName: z.string(),
-  lastName: z.string()
-});
+const signupSchema = z.object({
+  email: z.string().email(),
+  password: z.string().regex(PASSWORD_RULES, "Weak password"),
+  firstName: z.string().min(1),
+  lastName: z.string().min(1)
+});
@@
-export const authRoutes = (app: Elysia) =>
-  app.group("/auth", (app) =>
-    app
-      .post("/signup", async ({ body, request }) => {
-        const parsed = signupSchema.safeParse(body);
-        if (!parsed.success) {
-          return new Response(JSON.stringify({ error: "Invalid input" }), { status: 400 });
-        }
-        // TODO: create user
-        return new Response(JSON.stringify({ ok: true }));
-      })
-      .post("/signin", async ({ body }) => {
-        const { email, password } = body as { email: string; password: string };
-        // TODO: check password and return JWT
-        return new Response(JSON.stringify({ token: "mock" }));
-      })
-      .get("/verify-email", async ({ query }) => {
-        // TODO
-        return new Response(JSON.stringify({ ok: true }));
-      })
-  );
+export const authRoutes = (app: Elysia) =>
+  app.group("/auth", (app) =>
+    app
+      .use(ratelimitByIp({ windowSec: 900, max: 20 }))
+      .post("/signup", async ({ body, request }) => {
+        const parsed = signupSchema.safeParse(body);
+        if (!parsed.success) {
+          return new Response(JSON.stringify({ error: "Invalid input" }), { status: 400 });
+        }
+        const { email, password, firstName, lastName } = parsed.data;
+        const client = await pool.connect();
+        try {
+          const exists = await client.query("SELECT id FROM users WHERE email=$1", [email]);
+          if (exists.rowCount) {
+            return new Response(JSON.stringify({ error: "Email already in use" }), { status: 409 });
+          }
+          const password_hash = await bcrypt.hash(password, 12);
+          const userRes = await client.query(
+            `INSERT INTO users (email, password_hash, first_name, last_name, email_verified)
+             VALUES ($1,$2,$3,$4,false) RETURNING id,email`,
+            [email, password_hash, firstName, lastName]
+          );
+          const token = nanoid(48);
+          await client.query(
+            `INSERT INTO email_verifications (user_id, token, expires_at)
+             VALUES ($1,$2,NOW() + INTERVAL '2 days')`,
+            [userRes.rows[0].id, token]
+          );
+          // TODO: send email with token via email service
+          return new Response(JSON.stringify({ ok: true }), { status: 201 });
+        } finally {
+          client.release();
+        }
+      })
+      .post("/signin", async ({ body }) => {
+        const { email, password } = body as { email: string; password: string };
+        const client = await pool.connect();
+        try {
+          const res = await client.query(
+            "SELECT id, password_hash, email_verified, role FROM users WHERE email=$1",
+            [email]
+          );
+          if (!res.rowCount) return new Response(JSON.stringify({ error: "Invalid credentials" }), { status: 401 });
+          const ok = await bcrypt.compare(password, res.rows[0].password_hash);
+          if (!ok) return new Response(JSON.stringify({ error: "Invalid credentials" }), { status: 401 });
+          const token = jwt.sign(
+            { sub: res.rows[0].id, role: res.rows[0].role || "user" },
+            process.env.JWT_SECRET!,
+            { expiresIn: "15m" }
+          );
+          const refresh = jwt.sign({ sub: res.rows[0].id, kind: "refresh" }, process.env.JWT_SECRET!, { expiresIn: "30d" });
+          await client.query("INSERT INTO user_sessions(user_id, refresh_token) VALUES ($1,$2)", [res.rows[0].id, refresh]);
+          return new Response(JSON.stringify({ token, refresh }), { status: 200 });
+        } finally {
+          client.release();
+        }
+      })
+      .get("/verify-email", async ({ query }) => {
+        const token = (query as any)?.token as string;
+        if (!token) return new Response(JSON.stringify({ error: "Missing token" }), { status: 400 });
+        const res = await pool.query(
+          `UPDATE users u SET email_verified=true
+             FROM email_verifications ev
+            WHERE ev.token=$1 AND ev.user_id=u.id AND ev.expires_at>NOW()
+            RETURNING u.id`, [token]);
+        if (!res.rowCount) return new Response(JSON.stringify({ error: "Invalid/expired" }), { status: 400 });
+        await pool.query("DELETE FROM email_verifications WHERE token=$1", [token]);
+        return new Response(JSON.stringify({ ok: true }));
+      })
+  );
*** End Patch
*** End Patch
